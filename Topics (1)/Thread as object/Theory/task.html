<h2>Thread as object</h2>
<div class="step-text">
<h5 id="introduction">Introduction</h5>
<p>When you have already learned the basics of programming in Kotlin and the capabilities of the language, you move on to creating larger and more serious projects to develop your skills. In such projects, you think not only about the correct code execution but also about its effective execution. This is where you need <strong>threads</strong>, which allow you to execute some actions in your program in parallel instead of sequentially.</p>
<p>In this topic, you will learn what Kotlin threads are and how you can work with them in your code.</p>
<h5 id="threads-in-kotlin">Threads in Kotlin</h5>
<p>Kotlin was originally designed with built-in multithreading support. Threads are supported on the level of the JVM, the level of the language (special keywords), and the level of the standard library. Every Kotlin program has at least one thread, which is called <strong>main</strong>; it is created automatically by the JVM process to execute statements inside the <code class="java">main()</code> function. Any Kotlin program has some other default threads as well (for example, a separate thread for the garbage collector).</p>
<p>Throughout all stages of development of the Kotlin language, the approach to multithreading has changed from the use of low-level threads to some high-level abstractions. However, understanding the fundamental concept remains very important for a good developer.</p>
<h5 id="a-class-for-threads">A class for threads</h5>
<p>A thread is a sequence of instructions that a program can execute when it runs. Each thread is represented by an object â€“ an instance of the <code class="java">java.lang.Thread</code> class (or its subclass).</p>
<p>As you know, every program creates at least one thread: the main thread, which runs the <code class="java">main()</code> function, and such a program is called a single thread program. If you create one or more threads that will be performed in parallel, it becomes a multithreaded program. In the following topics, you will learn how to create your own thread, which will perform a certain sequence of actions. But now, let's try to look at the thread that executes at the moment.</p>
<p>The <code class="java">Thread</code> class has a static method named <code class="java">currentThread</code> to obtain a reference to the currently executing thread object:</p>
<pre><code class="java">val thread: Thread = Thread.currentThread() // the current thread</code></pre>
<p>The <code class="java">Thread</code> class stores basic information about the thread: its name, identifier (<code class="java">long</code>), priority, and some other characteristics that can be obtained through its functions. Let's study them in more detail and take the thread <code class="java">main</code> as an example.</p>
<h5 id="the-information-on-the-main-thread">The information on the main thread</h5>
<p>The example below demonstrates how to obtain the characteristics of the main<strong> </strong>thread by making references to it through an object of the <code class="java">Thread</code>class.</p>
<pre><code class="java">fun main() {
    val t: Thread = Thread.currentThread() // main thread

    println("Name: ${t.name}")
    println("ID: ${t.id}")
    println("Alive: ${t.isAlive}")
    println("Priority: ${t.priority}")
    println("Daemon: ${t.isDaemon}")
}
</code></pre>
<p>All statements in this program are executed by the main thread. You can see the general information about this thread:</p>
<ul>
<li><code class="java">t.name</code> returns the thread's name;</li>
<li><code class="java">t.id</code> returns the thread's unique identifier;</li>
<li><code class="java">t.isAlive</code> tells us whether the thread has been started and hasn't died yet;</li>
<li><code class="java">t.priority</code> returns the priority of the given thread. Every thread has a <strong>priority </strong>that determines the order of execution: threads with a higher priority are executed before threads with lower priorities;</li>
<li><code class="java">t.isDaemon</code> checks whether the thread is a <strong>daemon</strong>. A daemon thread (comes from UNIX terminology) is a low priority thread that runs in the background to perform tasks such as garbage collection and so on. The JVM does not wait for daemon threads to stop before exiting, while it does so for non-daemon threads.</li>
</ul>
<p>The output of the program:</p>
<pre><code class="java">Name: main
ID: 1
Alive: true
Priority: 5
Daemon: false
</code></pre>
<p>Each characteristic can be changed by setting a new value:</p>
<pre><code class="java">val t: Thread = Thread.currentThread() // main thread

t.name = "my-thread"
println("New name: ${t.name}") // New name: my-thread</code></pre>
<p>The same code can be applied to any current thread, not only the main one.</p>
<h5 id="conclusion">Conclusion</h5>
<p>In this topic, you've learned some useful information about threads:</p>
<ul>
<li>A thread is a sequence of instructions that can be performed in parallel.</li>
<li>The class <code class="java">Thread</code> allows working with a thread as an object.</li>
<li>You can obtain a reference to the currently executing thread using the static method <code class="java">Thread.currentThread()</code>.</li>
<li>Any thread has a name, an identifier, a priority, as well as isAlive and isDaemon characteristics, which you can change.</li>
</ul>
</div>
